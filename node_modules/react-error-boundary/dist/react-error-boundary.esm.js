import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';
import React from 'react';

var changedArray = function (a, b) {
  if (a === void 0) {
    a = [];
  }

  if (b === void 0) {
    b = [];
  }

  return a.length !== b.length || a.some(function (item, index) {
    return !Object.is(item, b[index]);
  });
};

var initialState = {
  error: null,
  info: null
};

var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.state = initialState;

    _this.resetErrorBoundary = function () {
      var _this$props;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);

      _this.setState(initialState);
    };

    return _this;
  }

  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error: error
    };
  };

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;

    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info == null ? void 0 : info.componentStack);
    this.setState({
      info: info
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$state = this.state,
        error = _this$state.error,
        info = _this$state.info;
    var resetKeys = this.props.resetKeys;

    if (error !== null && info !== null && changedArray(prevProps.resetKeys, resetKeys)) {
      var _this$props$onResetKe, _this$props3;

      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
      this.setState(initialState);
    }
  };

  _proto.render = function render() {
    var _this$state2 = this.state,
        error = _this$state2.error,
        info = _this$state2.info;
    var _this$props4 = this.props,
        fallbackRender = _this$props4.fallbackRender,
        FallbackComponent = _this$props4.FallbackComponent,
        fallback = _this$props4.fallback;

    if (error !== null) {
      // we'll get a re-render with the error state in getDerivedStateFromError
      // but we don't have the info yet, so just render null
      // note that this won't be committed to the DOM thanks to our componentDidCatch
      // so the user won't see a flash of nothing, so this works fine.
      // the benefit of doing things this way rather than just putting both the
      // error and info setState within componentDidCatch is we avoid re-rendering
      // busted stuff: https://github.com/bvaughn/react-error-boundary/issues/66
      if (!info) return null;
      var props = {
        componentStack: info == null ? void 0 : info.componentStack,
        error: error,
        resetErrorBoundary: this.resetErrorBoundary
      };

      if ( /*#__PURE__*/React.isValidElement(fallback)) {
        return fallback;
      } else if (typeof fallbackRender === 'function') {
        return fallbackRender(props);
      } else if (FallbackComponent) {
        return /*#__PURE__*/React.createElement(FallbackComponent, props);
      } else {
        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');
      }
    }

    return this.props.children;
  };

  return ErrorBoundary;
}(React.Component);

function withErrorBoundary(Component, errorBoundaryProps) {
  function Wrapped(props) {
    return /*#__PURE__*/React.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React.createElement(Component, props));
  } // Format for display in DevTools


  var name = Component.displayName || Component.name || 'Unknown';
  Wrapped.displayName = "withErrorBoundary(" + name + ")";
  return Wrapped;
}

function useErrorHandler(givenError) {
  var _React$useState = React.useState(null),
      error = _React$useState[0],
      setError = _React$useState[1];

  if (givenError) throw givenError;
  if (error) throw error;
  return setError;
}

export { ErrorBoundary, useErrorHandler, withErrorBoundary };
