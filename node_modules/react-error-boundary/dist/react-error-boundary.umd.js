(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactErrorBoundary = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var changedArray = function (a, b) {
    if (a === void 0) {
      a = [];
    }

    if (b === void 0) {
      b = [];
    }

    return a.length !== b.length || a.some(function (item, index) {
      return !Object.is(item, b[index]);
    });
  };

  var initialState = {
    error: null,
    info: null
  };

  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(ErrorBoundary, _React$Component);

    function ErrorBoundary() {
      var _this;

      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
      _this.state = initialState;

      _this.resetErrorBoundary = function () {
        var _this$props;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);

        _this.setState(initialState);
      };

      return _this;
    }

    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
      return {
        error: error
      };
    };

    var _proto = ErrorBoundary.prototype;

    _proto.componentDidCatch = function componentDidCatch(error, info) {
      var _this$props$onError, _this$props2;

      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info == null ? void 0 : info.componentStack);
      this.setState({
        info: info
      });
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var _this$state = this.state,
          error = _this$state.error,
          info = _this$state.info;
      var resetKeys = this.props.resetKeys;

      if (error !== null && info !== null && changedArray(prevProps.resetKeys, resetKeys)) {
        var _this$props$onResetKe, _this$props3;

        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
        this.setState(initialState);
      }
    };

    _proto.render = function render() {
      var _this$state2 = this.state,
          error = _this$state2.error,
          info = _this$state2.info;
      var _this$props4 = this.props,
          fallbackRender = _this$props4.fallbackRender,
          FallbackComponent = _this$props4.FallbackComponent,
          fallback = _this$props4.fallback;

      if (error !== null) {
        // we'll get a re-render with the error state in getDerivedStateFromError
        // but we don't have the info yet, so just render null
        // note that this won't be committed to the DOM thanks to our componentDidCatch
        // so the user won't see a flash of nothing, so this works fine.
        // the benefit of doing things this way rather than just putting both the
        // error and info setState within componentDidCatch is we avoid re-rendering
        // busted stuff: https://github.com/bvaughn/react-error-boundary/issues/66
        if (!info) return null;
        var props = {
          componentStack: info == null ? void 0 : info.componentStack,
          error: error,
          resetErrorBoundary: this.resetErrorBoundary
        };

        if ( /*#__PURE__*/React__default['default'].isValidElement(fallback)) {
          return fallback;
        } else if (typeof fallbackRender === 'function') {
          return fallbackRender(props);
        } else if (FallbackComponent) {
          return /*#__PURE__*/React__default['default'].createElement(FallbackComponent, props);
        } else {
          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');
        }
      }

      return this.props.children;
    };

    return ErrorBoundary;
  }(React__default['default'].Component);

  function withErrorBoundary(Component, errorBoundaryProps) {
    function Wrapped(props) {
      return /*#__PURE__*/React__default['default'].createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React__default['default'].createElement(Component, props));
    } // Format for display in DevTools


    var name = Component.displayName || Component.name || 'Unknown';
    Wrapped.displayName = "withErrorBoundary(" + name + ")";
    return Wrapped;
  }

  function useErrorHandler(givenError) {
    var _React$useState = React__default['default'].useState(null),
        error = _React$useState[0],
        setError = _React$useState[1];

    if (givenError) throw givenError;
    if (error) throw error;
    return setError;
  }

  exports.ErrorBoundary = ErrorBoundary;
  exports.useErrorHandler = useErrorHandler;
  exports.withErrorBoundary = withErrorBoundary;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-error-boundary.umd.js.map
